<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ì‹¤ì‹œê°„ ìŠ¤ì¼€ì¹˜ë¶ + AI ì±„íŒ…</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
  <script src="https://t1.kakaocdn.net/kakao_js_sdk/2.7.2/kakao.min.js"></script>

  <style>
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #e5e5e5; }
    #viewport { width: 100%; height: 100%; overflow: hidden; touch-action: none; cursor: crosshair; }
    canvas { display: block; background-color: white; box-shadow: 0 0 50px rgba(0,0,0,0.1); transform-origin: 0 0; }
    
    /* íˆ´ë°” ìŠ¤íƒ€ì¼ */
    .toolbar {
      position: fixed; bottom: 0; left: 0; width: 100%; box-sizing: border-box;
      display: flex; align-items: center; justify-content: flex-start;
      background: white; border-top: 1px solid #eee; border-radius: 20px 20px 0 0;
      box-shadow: 0 -5px 20px rgba(0,0,0,0.05); z-index: 100;
      overflow-x: auto; white-space: nowrap; padding: 15px 20px; gap: 15px;
      padding-bottom: max(15px, env(safe-area-inset-bottom));
    }
    .toolbar::-webkit-scrollbar { display: none; }
    .color-btn { flex-shrink: 0; width: 32px; height: 32px; border-radius: 50%; border: 2px solid #eee; cursor: pointer; }
    .color-btn.active { transform: scale(1.1); border-color: #555; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    .tool-btn { flex-shrink: 0; background: #f5f5f5; border: none; border-radius: 12px; width: 40px; height: 40px; font-size: 20px; color: #555; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .tool-btn.active { background: #333; color: white; }
    .kakao-btn { background-color: #FEE500; color: #3c1e1e; }
    .divider { flex-shrink: 0; width: 1px; height: 24px; background: #eee; margin: 0 5px; }
    
    /* í…ìŠ¤íŠ¸ ì…ë ¥ì°½ */
    #textInput { position: fixed; z-index: 1000; display: none; background: transparent; border: 2px dashed #333; font-size: 20px; padding: 5px; color: #333; outline: none; min-width: 100px; }
    
    /* ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
    #imgModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; flex-direction: column; align-items: center; justify-content: center; }
    #previewContainer { position: relative; max-width: 90%; max-height: 60%; border: 2px solid white; overflow: hidden; display: flex; align-items: center; justify-content: center; background: #333; }
    #previewImg { max-width: 100%; max-height: 100%; object-fit: contain; }
    #modalControls { margin-top: 20px; width: 90%; max-width: 400px; display: flex; flex-direction: column; gap: 15px; align-items: center; background: white; padding: 20px; border-radius: 15px; }
    input[type=range] { width: 100%; } .modal-btns { display: flex; gap: 10px; width: 100%; } .modal-btn { flex: 1; padding: 12px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px; } .btn-confirm { background: #007aff; color: white; } .btn-cancel { background: #eee; color: #333; }

    /* â–¼â–¼â–¼ [NEW] ì±„íŒ… ë¡œê·¸ ìŠ¤íƒ€ì¼ ì¶”ê°€ â–¼â–¼â–¼ */
    #chat-log {
      position: fixed;
      background: rgba(0, 0, 0, 0.6); /* ë°˜íˆ¬ëª… ê²€ì€ìƒ‰ */
      color: white;
      padding: 15px;
      overflow-y: auto; /* ë‚´ìš© ë§ìœ¼ë©´ ìŠ¤í¬ë¡¤ */
      z-index: 900; /* ìº”ë²„ìŠ¤ë³´ë‹¤ ìœ„ì—, ëª¨ë‹¬ë³´ë‹¨ ì•„ë˜ */
      font-family: sans-serif;
      backdrop-filter: blur(5px);
      border-radius: 15px;
      pointer-events: none; /* í´ë¦­ í†µê³¼ (ê·¸ë¦¼ ê·¸ë¦¬ê¸° ë°©í•´ ì•ˆ ë˜ê²Œ) */
    }
    
    /* ë©”ì‹œì§€ í•œ ì¤„ */
    .log-message {
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
      text-shadow: 1px 1px 2px black;
      animation: fadeIn 0.3s ease-out; /* ë¶€ë“œëŸ½ê²Œ ë“±ì¥ */
    }

    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    /* ğŸ–¥ï¸ PC í™”ë©´: ì˜¤ë¥¸ìª½ ì‚¬ì´ë“œë°” */
    @media (min-width: 768px) {
      #chat-log {
        top: 20px;
        right: 20px;
        bottom: 100px; /* íˆ´ë°” ìœ„ê¹Œì§€ */
        width: 300px;
        max-height: 80%;
      }
    }

    /* ğŸ“± ëª¨ë°”ì¼ í™”ë©´: ìƒë‹¨ ë°°ë„ˆ */
    @media (max-width: 767px) {
      #chat-log {
        top: 10px;
        left: 10px;
        right: 10px;
        height: 120px; /* ë†’ì´ ì œí•œ */
        font-size: 12px; /* ê¸€ì ì¡°ê¸ˆ ì‘ê²Œ */
      }
    }
  </style>
</head>
<body>
  <div id="chat-log">
    <div class="log-message" style="color: #ffff00;">ğŸ¤– ì‹œìŠ¤í…œ: AI ì¹œêµ¬ê°€ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤!</div>
  </div>

  <div id="viewport"><canvas id="myCanvas"></canvas></div>
  <input type="text" id="textInput" placeholder="ì…ë ¥ í›„ ì—”í„°">
  <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="openImageModal(this)">
   
  <div id="imgModal">
    <div id="previewContainer"><img id="previewImg" src=""></div>
    <div id="modalControls">
      <div style="width:100%; display:flex; justify-content:space-between; font-size:14px; color:#555;"><span>ì‘ê²Œ</span><span>í¬ê²Œ</span></div>
      <input type="range" id="sizeSlider" min="50" max="1000" value="300">
      <div class="modal-btns">
        <button class="modal-btn btn-cancel" onclick="closeModal()">ì·¨ì†Œ</button>
        <button class="modal-btn btn-confirm" onclick="confirmUpload()">ì´ëŒ€ë¡œ ì˜¬ë¦¬ê¸°</button>
      </div>
    </div>
  </div>

  <div class="toolbar">
    <div class="color-btn active" style="background:#222" onclick="setColor('#222', this)"></div>
    <div class="color-btn" style="background:#ff3b30" onclick="setColor('#ff3b30', this)"></div>
    <div class="color-btn" style="background:#007aff" onclick="setColor('#007aff', this)"></div>
    <div class="divider"></div>
    <button class="tool-btn material-icons-round" onclick="toggleWidth(this)">line_weight</button>
    <button class="tool-btn material-icons-round" id="eraserBtn" onclick="setMode('eraser', this)">auto_fix_normal</button>
    <div class="divider"></div>
    <button class="tool-btn material-icons-round" id="textBtn" onclick="setMode('text', this)">title</button>
    <button class="tool-btn material-icons-round" onclick="document.getElementById('fileInput').click()">add_photo_alternate</button>
    <div class="divider"></div>
    <button class="tool-btn material-icons-round" onclick="undoLast()">undo</button>
    <button class="tool-btn material-icons-round kakao-btn" onclick="shareKakao()">chat_bubble</button>
    <button class="tool-btn material-icons-round" onclick="saveImage()">save_alt</button>
    <button class="tool-btn material-icons-round" style="color:#ff3b30" onclick="clearAll()">delete</button>
    <button class="tool-btn" style="width:auto; padding:0 10px; font-size:14px; font-weight:bold; color:#007aff;" onclick="askAI()">ğŸ¤– AIë§ì¶°ë´</button>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    try { Kakao.init(); } catch(e) {} 

    const socket = io();
    const viewport = document.getElementById('viewport');
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    const textInput = document.getElementById('textInput');
    const imgModal = document.getElementById('imgModal');
    const previewImg = document.getElementById('previewImg');
    const sizeSlider = document.getElementById('sizeSlider');

    const VIRTUAL_WIDTH = 3000, VIRTUAL_HEIGHT = 3000;
    canvas.width = VIRTUAL_WIDTH; canvas.height = VIRTUAL_HEIGHT;

    let current = { color: '#222', width: 3, mode: 'draw' };
    let isDown = false, isDrawing = false, startPos = {x:0,y:0};
    let scale = 1, panX = (window.innerWidth-VIRTUAL_WIDTH)/2, panY = (window.innerHeight-VIRTUAL_HEIGHT)/2;
    let isSpacePressed = false, isMousePanning = false, panStartMouse = null;
    let tempImgData = null;
    let currentStrokeId = null;

    updateTransform();
    function updateTransform() { canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`; }
    function getPos(clientX, clientY) { return { x: (clientX - panX) / scale, y: (clientY - panY) / scale }; }

    // â–¼â–¼â–¼ [NEW] ì±„íŒ… ë¡œê·¸ í•¨ìˆ˜ ì¶”ê°€ â–¼â–¼â–¼
    function addLog(text, color = 'white') {
      const chatBox = document.getElementById('chat-log');
      const msgDiv = document.createElement('div');
      msgDiv.className = 'log-message';
      msgDiv.innerText = text;
      msgDiv.style.color = color;
      chatBox.appendChild(msgDiv);
      chatBox.scrollTop = chatBox.scrollHeight; // ìë™ ìŠ¤í¬ë¡¤
    }

    function drawLine(x0, y0, x1, y1, style, emit) {
      ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1);
      ctx.strokeStyle = style.color; ctx.lineWidth = style.width; ctx.lineCap = 'round';
      ctx.globalCompositeOperation = style.mode === 'eraser' ? 'destination-out' : 'source-over';
      ctx.stroke(); ctx.closePath();
      if (emit) socket.emit('drawing', { x0, y0, x1, y1, color: style.color, width: style.width, mode: style.mode, strokeId: currentStrokeId });
    }
    
    function drawDot(pos, style, emit) {
      ctx.beginPath(); ctx.arc(pos.x, pos.y, style.width / 2, 0, Math.PI * 2);
      ctx.fillStyle = style.color; ctx.globalCompositeOperation = style.mode === 'eraser' ? 'destination-out' : 'source-over';
      ctx.fill(); ctx.closePath();
      if (emit) socket.emit('drawing', { x0: pos.x, y0: pos.y, x1: pos.x, y1: pos.y, color: style.color, width: style.width, mode: style.mode, strokeId: currentStrokeId });
    }

    function drawImageObj(data, emit) {
      const img = new Image();
      img.onload = () => { ctx.globalCompositeOperation = 'source-over'; ctx.drawImage(img, data.x, data.y, data.w, data.h); };
      img.src = data.src;
      if (emit) socket.emit('image', data);
    }
    function drawTextObj(data, emit) {
      ctx.globalCompositeOperation = 'source-over'; ctx.font = "bold 40px sans-serif"; ctx.fillStyle = data.color; ctx.fillText(data.text, data.x, data.y);
      if (emit) socket.emit('text', data);
    }

    // ëª¨ë‹¬ ë° ì´ë¯¸ì§€ ë¡œì§
    function openImageModal(input) {
      const file = input.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => { tempImgData = e.target.result; previewImg.src = tempImgData; imgModal.style.display = 'flex'; sizeSlider.value = 300; sizeSlider.max = Math.min(window.innerWidth, 1000); updatePreview(); };
      reader.readAsDataURL(file); input.value = '';
    }
    sizeSlider.oninput = updatePreview;
    function updatePreview() { previewImg.style.width = sizeSlider.value + 'px'; }
    function closeModal() { imgModal.style.display = 'none'; tempImgData = null; }
    function confirmUpload() {
      if (!tempImgData) return;
      const img = new Image();
      img.onload = () => {
        const MAX = 1000; let dw=img.width, dh=img.height;
        if (dw > MAX) { dh *= MAX/dw; dw = MAX; }
        const tCan = document.createElement('canvas'); tCan.width = dw; tCan.height = dh;
        tCan.getContext('2d').drawImage(img, 0, 0, dw, dh);
        const compressed = tCan.toDataURL('image/jpeg', 0.7);
        const userW = parseInt(sizeSlider.value); const userH = userW * (img.height/img.width);
        const center = getPos(window.innerWidth/2, window.innerHeight/2);
        drawImageObj({ src: compressed, x: center.x-userW/2, y: center.y-userH/2, w: userW, h: userH }, true);
        closeModal();
      };
      img.src = tempImgData;
    }

    // í…ìŠ¤íŠ¸ ë¡œì§
    function handleCanvasClick(e) {
      if (current.mode !== 'text') return;
      if (textInput.style.display === 'block') { finishText(getPos(e.clientX, e.clientY)); return; }
      const p = getPos(e.clientX, e.clientY);
      textInput.style.display = 'block'; textInput.style.left = e.clientX+'px'; textInput.style.top = e.clientY+'px';
      textInput.style.color = current.color; textInput.value = ''; setTimeout(() => textInput.focus(), 10);
      textInput.onkeyup = (key) => { if (key.key === 'Enter') finishText(p); };
      textInput.onblur = () => { finishText(p); };
    }
    function finishText(pos) {
      if (textInput.value.trim() !== '') drawTextObj({ text: textInput.value, x: pos.x, y: pos.y, color: current.color }, true);
      textInput.style.display = 'none'; textInput.value = ''; setMode('draw', document.querySelector('.color-btn.active'));
    }

    // ì…ë ¥ ì´ë²¤íŠ¸
    window.addEventListener('keydown', (e) => { if (e.code === 'Space') { isSpacePressed = true; viewport.style.cursor = 'grab'; } });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') { isSpacePressed = false; viewport.style.cursor = 'crosshair'; isMousePanning = false; } });

    viewport.addEventListener('mousedown', (e) => {
      if (current.mode === 'text') { handleCanvasClick(e); return; }
      if (isSpacePressed || e.button === 1) { isMousePanning = true; panStartMouse = { x: e.clientX, y: e.clientY }; e.preventDefault(); }
      else { 
        isDown = true; isDrawing = false; 
        const p = getPos(e.clientX, e.clientY); lastCenter = p; startPos = p; 
        currentStrokeId = Date.now() + Math.random(); 
      }
    });
    viewport.addEventListener('mousemove', (e) => {
      if (current.mode === 'text') return;
      if (isMousePanning) { panX += e.clientX - panStartMouse.x; panY += e.clientY - panStartMouse.y; panStartMouse = { x: e.clientX, y: e.clientY }; updateTransform(); }
      else if (isDown) {
        const p = getPos(e.clientX, e.clientY);
        if (!isDrawing) { if (Math.hypot(p.x - startPos.x, p.y - startPos.y) > 3) isDrawing = true; }
        if (isDrawing) drawLine(lastCenter.x, lastCenter.y, p.x, p.y, current, true);
        lastCenter = p;
      }
    });
    viewport.addEventListener('mouseup', () => { if (current.mode === 'text') return; if (isDown && !isDrawing) drawDot(startPos, current, true); isDown = false; isDrawing = false; isMousePanning = false; });

    let lastCenter = null, startDist = 0, startScale = 1, startPanX = 0, startPanY = 0;
    viewport.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1 && current.mode === 'text') { handleCanvasClick(e.touches[0]); e.preventDefault(); return; }
      if (e.touches.length === 2) {
        isDown = false; isDrawing = false;
        startDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        startScale = scale; startPanX = panX; startPanY = panY;
        lastCenter = { x: (e.touches[0].clientX + e.touches[1].clientX)/2, y: (e.touches[0].clientY + e.touches[1].clientY)/2 };
      } else if (e.touches.length === 1) { 
        isDown = true; isDrawing = false; 
        const p = getPos(e.touches[0].clientX, e.touches[0].clientY); lastCenter = p; startPos = p;
        currentStrokeId = Date.now() + Math.random();
      }
    }, { passive: false });
    viewport.addEventListener('touchmove', (e) => {
      if (current.mode === 'text') return;
      if (e.touches.length === 2 && lastCenter) {
        const cx = (e.touches[0].clientX + e.touches[1].clientX)/2, cy = (e.touches[0].clientY + e.touches[1].clientY)/2;
        const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        if (startDist > 0) {
          scale = Math.min(Math.max(0.1, startScale * (dist/startDist)), 5);
          const wx = (lastCenter.x - startPanX)/startScale, wy = (lastCenter.y - startPanY)/startScale;
          panX = cx - wx*scale; panY = cy - wy*scale;
        }
        updateTransform();
      } else if (isDown && e.touches.length === 1) {
        const p = getPos(e.touches[0].clientX, e.touches[0].clientY);
        if (!isDrawing) { if (Math.hypot(p.x - startPos.x, p.y - startPos.y) > 5) isDrawing = true; if(isDrawing) drawLine(startPos.x, startPos.y, p.x, p.y, current, true); }
        if (isDrawing) drawLine(lastCenter.x, lastCenter.y, p.x, p.y, current, true);
        lastCenter = p;
      }
    }, { passive: false });
    viewport.addEventListener('touchend', (e) => { if (current.mode === 'text') return; if (isDown && !isDrawing && e.touches.length === 0) drawDot(startPos, current, true); isDown = false; isDrawing = false; lastCenter = null; });
    
    viewport.addEventListener('wheel', (e) => { e.preventDefault(); const newScale = Math.min(Math.max(0.1, scale + (scale * -e.deltaY * 0.0005)), 5); const mx = (e.clientX - panX)/scale, my = (e.clientY - panY)/scale; scale = newScale; panX = e.clientX - mx*scale; panY = e.clientY - my*scale; updateTransform(); }, { passive: false });

    // ì†Œì¼“ ìˆ˜ì‹ 
    socket.on('drawing', (d) => { if (d.x0===d.x1 && d.y0===d.y1) drawDot({x:d.x0,y:d.y0},d,false); else drawLine(d.x0,d.y0,d.x1,d.y1,d,false); });
    socket.on('image', (d) => drawImageObj(d, false));
    socket.on('text', (d) => drawTextObj(d, false));
    socket.on('history', (h) => h.forEach(d => {
      if (d.type === 'image') drawImageObj(d, false);
      else if (d.type === 'text') drawTextObj(d, false);
      else { if (d.x0===d.x1 && d.y0===d.y1) drawDot({x:d.x0,y:d.y0},d,false); else drawLine(d.x0,d.y0,d.x1,d.y1,d,false); }
    }));
    socket.on('clear', () => ctx.clearRect(0,0,canvas.width,canvas.height));

    // UI í•¨ìˆ˜
    function setMode(m,b) { current.mode = m; document.querySelectorAll('.tool-btn').forEach(x=>x.classList.remove('active')); if(b) b.classList.add('active'); if(m==='eraser') document.querySelectorAll('.color-btn').forEach(x=>x.classList.remove('active')); if(m!=='text') textInput.style.display='none'; }
    function setColor(c,b) { current.color=c; setMode('draw',null); document.querySelectorAll('.color-btn').forEach(x=>x.classList.remove('active')); b.classList.add('active'); document.getElementById('eraserBtn').classList.remove('active'); document.getElementById('textBtn').classList.remove('active'); }
    function toggleWidth(el) { current.width = (current.width===3)?10:3; el.style.fontWeight = (current.width===10)?'bold':'normal'; }
    function clearAll() { socket.emit('clear'); }
    function saveImage() { const a=document.createElement('a'); a.download='sketch.png'; a.href=canvas.toDataURL(); a.click(); }
    function shareKakao() { if (!Kakao.isInitialized()) { alert('í‚¤ ì˜¤ë¥˜'); return; } Kakao.Share.sendDefault({ objectType: 'feed', content: { title: 'ê·¸ë¦¼íŒ', description: 'ì ‘ì†!', imageUrl: '', link: { mobileWebUrl: location.href, webUrl: location.href } }, buttons: [{ title: 'ê°€ê¸°', link: { mobileWebUrl: location.href, webUrl: location.href } }] }); }
    function undoLast() { socket.emit('undo'); }

    // â–¼â–¼â–¼ [ìˆ˜ì •ë¨] í˜„ì¬ ë³´ê³  ìˆëŠ” í™”ë©´ë§Œ ì˜ë¼ì„œ ë³´ë‚´ëŠ” í•¨ìˆ˜ â–¼â–¼â–¼
function askAI() {
  // 1. ì„ì‹œ ìº”ë²„ìŠ¤ ë§Œë“¤ê¸° (í˜„ì¬ ë‚´ í™”ë©´ í¬ê¸°ë§Œí¼)
  const tempCanvas = document.createElement('canvas');
  const tCtx = tempCanvas.getContext('2d');
  
  tempCanvas.width = window.innerWidth;
  tempCanvas.height = window.innerHeight;

  // 2. ë°°ê²½ì„ í°ìƒ‰ìœ¼ë¡œ ì¹ í•˜ê¸° (íˆ¬ëª…í•˜ë©´ AIê°€ í—·ê°ˆë ¤í•¨)
  tCtx.fillStyle = "white";
  tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

  // 3. í˜„ì¬ ë³´ê³  ìˆëŠ” ì˜ì—­ ê³„ì‚°í•˜ê¸° (ìˆ˜í•™ ì‹œê°„! ğŸ“)
  // í™”ë©´ì˜ (0,0)ì´ ìº”ë²„ìŠ¤ì˜ ì–´ë””ì— í•´ë‹¹í•˜ëŠ”ì§€ ì—­ê³„ì‚°
  const sx = -panX / scale;
  const sy = -panY / scale;
  const sWidth = window.innerWidth / scale;
  const sHeight = window.innerHeight / scale;

  // 4. ì›ë³¸ ìº”ë²„ìŠ¤ì—ì„œ ë³´ê³  ìˆëŠ” ë¶€ë¶„ë§Œ ì„ì‹œ ìº”ë²„ìŠ¤ë¡œ ë³µì‚¬
  // drawImage(ì›ë³¸, ê°€ì ¸ì˜¬X, ê°€ì ¸ì˜¬Y, ê°€ì ¸ì˜¬ë„ˆë¹„, ê°€ì ¸ì˜¬ë†’ì´, ê·¸ë¦´X, ê·¸ë¦´Y, ê·¸ë¦´ë„ˆë¹„, ê·¸ë¦´ë†’ì´)
  tCtx.drawImage(canvas, sx, sy, sWidth, sHeight, 0, 0, tempCanvas.width, tempCanvas.height);

  // 5. ì˜ë¼ë‚¸ ì´ë¯¸ì§€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  const cropImage = tempCanvas.toDataURL("image/png");

  // 6. ì„œë²„ë¡œ ì „ì†¡
  socket.emit('guess_request', cropImage);
  addLog("ğŸ¤– AI: í™”ë©´ì— ë³´ì´ëŠ” ê±¸ ë¶„ì„ ì¤‘ì´ì—ìš”...", "#aaa");
}
  </script>
</body>
</html>
